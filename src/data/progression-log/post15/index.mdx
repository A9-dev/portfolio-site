---
pubDate: "2026-01-26"
updatedDate: "2026-02-03"
worklog:
  - type: "conference"
    area: ["NDC London, Workshop"]
    summary: "The Hitchhiker's Guide to Computer Science"
---

## The Hitchhiker's Guide to Computer Science

This was a workshop I attended at [NDC London](https://ndclondon.com) 2026!

https://ndclondon.com/workshops/the-hitchhiker-s-guide-to-computer-science/8cc91f1aec3d

### Description

There are many cases of performance, correctness, design and security, however, where foundational concepts taken for granted by those with a more formal background would benefit software developers who might otherwise not have had the opportunity to learn about them.

Three broad topic areas will be covered during the day: low-level representation; data structures and algorithms; distribution and concurrency.

- Welcome to the Machine: Modern programming languages, libraries and operating systems hide a lot of the lower-level machine detail. A developer can easily ignore much of what happens beneath the virtualisation of their runtime or the abstractions of their high-level programming language. Much of... but not all of. To understand a number of edge cases, failures cases and surprising cases, developers should be familiar with the various ways in which numbers are represented. It also helps to understand how memory is addressed, both physically and virtually, and how to perform bit manipulation when needed. And when we talk about memory, we also need to talk about processor caching, instruction pipelines, speculative execution and, of course, that virtual machines are still machines. All of these considerations have an impact on the mechanical sympathy and, therefore, the performance of code, as well as its correctness and security.

- Everything in its Right Place: Most of the time, the data structures we need can be found commodified in a programming language's standard library, along with a number of useful algorithms. But, as many codebases witness, most developers rarely venture beyond array-like collections, often with unintended performance consequences or verbose code. And for those who do, there is often not a full appreciation of how hashing- and ordering-based collections work and the trade-offs they involves. In this module, common concrete and abstract data types will be examined in terms of their structure and performance characteristics, as well as some common and esoteric algorithms understood in terms of their time and cache behaviour, with a proper appreciation of what big O notation does and does not entail.

- Go with the Flow: Although many developers find themselves working in software architectures reliant on networks and in languages that freely offer support for multithreading, they often lack a more formal understanding of the principles, theorems and guidelines that govern these domains. In this module, we will introduce happens-before semantics, TOCTOU errors, how deadlocks and livelocks occur, the fallacies of distributed computing, CAP theorem and PACELC theorem, along with how to work within these constraints and avoid common pitfalls.

This full-day session is suitable for anyone in software development with a past, present and future programming role, whether as an introduction or as a refresher.
